<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Simple variable interpolation in R</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
#toc {
  position: fixed;
  left: 0;
  top: 20px;
  width: 200px;
  height: 100%;
  overflow:auto;
  padding: 0px 10px 0px 10px;
}
#toc_header {
  display: none;
}
#toc ul {
  margin: 0px;
  padding: 0px;
}
#toc ul li {
  list-style-type: none;
}

#toc ul li ul li {
  margin-left: 15px;
  list-style-type: circle;
}
body, td {
   font-family: Arial,Helvetica,sans-serif;
   background-color: white;
   font-size: 13px;
  max-width: 800px;
  margin: auto;
  margin-left:210px;
  padding: 0px 10px 0px 10px;
  border-left: 1px solid #EEEEEE;
  line-height: 150%;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, 

monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a {
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<div id="toc">
<div id="toc_header">Table of Contents</div>
<ul>
<li>
<a href="#toc_0">Simple variable interpolation in R</a>
<ul>
<li>
<a href="#toc_1">Code patterns</a>
</li>
<li>
<a href="#toc_2">Where to look for variables</a>
</li>
<li>
<a href="#toc_3">Variables should only return vectors</a>
</li>
<li>
<a href="#toc_4">You can also interpolate more complicated codes</a>
</li>
<li>
<a href="#toc_5">Simple template system</a>
</li>
<li>
<a href="#toc_6">Session info</a>
</li>
</ul>
</li>
</ul>
</div>


<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Simple variable interpolation in R}
-->

<h1 id="toc_0">Simple variable interpolation in R</h1>

<p><strong>Author</strong>: Zuguang Gu ( <a href="mailto:z.gu@dkfz.de">z.gu@dkfz.de</a> )</p>

<p><strong>Date</strong>: 2017-03-06</p>

<hr/>

<p>There are several ways to construct strings in <strong>R</strong> such as <code>paste()</code>. However,
when the string which is going to be constructed is too complex, using <code>paste()</code>
can be a pain. For example, we want to put some parameters as title in a plot.</p>

<pre><code class="r">region = c(1, 2)
value = 4
name = &quot;name&quot;
str = paste(&quot;region = (&quot;, region[1], &quot;, &quot;, region[2], &quot;), value = &quot;, value, 
            &quot;, name = &#39;&quot;, name, &quot;&#39;&quot;, sep = &quot;&quot;)
cat(str)
</code></pre>

<pre><code>## region = (1, 2), value = 4, name = &#39;name&#39;
</code></pre>

<p>As you can see, it is hard to read and very easy to make mistakes. (Syntax highlighting may be 
helpful to match quotes, but it is still quite annoying to see so many commas and quotes.)</p>

<p>In <strong>Perl</strong>, we always use variable interpolation to construct complex strings in 
which variables are started with special marks (sigil), and variables will be replaced with
their real values. In this package, we aim to implement variable interpolation in <em>R</em>.
The idea is rather simple: use special marks to identify variables and then
replace with their values. The function here is <code>qq()</code> which is named from the
subroutine with the same name in <strong>Perl</strong> (It stands for double quote). Using variable interpolation, above
example can be written as:</p>

<pre><code class="r">library(GetoptLong)

str = qq(&quot;region = (@{region[1]}, @{region[2]}), value = @{value}, name = &#39;@{name}&#39;&quot;)
cat(str)
</code></pre>

<pre><code>## region = (1, 2), value = 4, name = &#39;name&#39;
</code></pre>

<p>Or use the shortcut function <code>qqcat()</code>:</p>

<pre><code class="r">qqcat(&quot;region = (@{region[1]}, @{region[2]}), value = @{value}, name = &#39;@{name}&#39;&quot;)
</code></pre>

<pre><code>## region = (1, 2), value = 4, name = &#39;name&#39;
</code></pre>

<p>One feature of <code>qqcat()</code> is you can set a global prefix to the messages by <code>qq.options(&quot;cat_prefix&quot;)</code>, 
either a string or a function. If it is set as a function, the value will be generated at real time
by executing the function.</p>

<pre><code class="r">qq.options(&quot;cat_prefix&quot; = &quot;[INFO] &quot;)
qqcat(&quot;This is a message&quot;)
</code></pre>

<pre><code>## [INFO] This is a message
</code></pre>

<pre><code class="r">qq.options(&quot;cat_prefix&quot; = function() format(Sys.time(), &quot;[%Y-%m-%d %H:%M:%S] &quot;))
qqcat(&quot;This is a message&quot;)
</code></pre>

<pre><code>## [2017-03-06 17:09:59] This is a message
</code></pre>

<pre><code class="r">Sys.sleep(2)
qqcat(&quot;This is a message after 2 seconds&quot;)
</code></pre>

<pre><code>## [2017-03-06 17:10:01] This is a message after 2 seconds
</code></pre>

<pre><code class="r">qq.options(&quot;cat_prefix&quot; = &quot;&quot;)
qqcat(&quot;This is a message&quot;)
</code></pre>

<pre><code>## This is a message
</code></pre>

<p>You can shut down all messages produced by <code>qqcat()</code> by <code>qq.options(&quot;cat_verbose&quot; = FALSE)</code>. </p>

<pre><code class="r">qq.options(&quot;cat_prefix&quot; = &quot;[INFO] &quot;, &quot;cat_verbose&quot; = FALSE)
qqcat(&quot;This is a message&quot;)
</code></pre>

<p>Also you can set a prefix which has local effect. </p>

<pre><code class="r">qq.options(RESET = TRUE)
qq.options(&quot;cat_prefix&quot; = &quot;[DEBUG] &quot;)
qqcat(&quot;This is a message&quot;, cat_prefix = &quot;[INFO] &quot;)
</code></pre>

<pre><code>## [INFO] This is a message
</code></pre>

<pre><code class="r">qqcat(&quot;This is a message&quot;)
</code></pre>

<pre><code>## [DEBUG] This is a message
</code></pre>

<p>From version 1.1.2, <code>qq.options()</code> can work in a local mode in which
the copy of the options only work in a local chunk.</p>

<pre><code class="r">qq.options(&quot;cat_prefix&quot; = &quot;[DEBUG] &quot;)
qq.options(LOCAL = TRUE)
qq.options(&quot;cat_prefix&quot; = &quot;[INFO] &quot;)
qqcat(&quot;This is the first message&quot;)
</code></pre>

<pre><code>## [INFO] This is the first message
</code></pre>

<pre><code class="r">qqcat(&quot;This is the second message&quot;)
</code></pre>

<pre><code>## [INFO] This is the second message
</code></pre>

<pre><code class="r">qq.options(LOCAL = FALSE)
qqcat(&quot;This is the third message&quot;)
</code></pre>

<pre><code>## [DEBUG] This is the third message
</code></pre>

<p>Reset the options so that it does not affect example code in following part of the vignette.</p>

<pre><code class="r">qq.options(RESET = TRUE)
</code></pre>

<p>You can use <code>cat_verbose</code> together with <code>GetoptLong()</code> when you want to run the R script in command line.
In following example code, if you do not specify <code>--verbose</code>, all messages will be shut down.</p>

<pre><code class="r">library(GetoptLong)
GetoptLong(c(
    &quot;verbose&quot;, &quot;Print message&quot;
))
qq.options(&quot;cat_verbose&quot; = verbose)
qqcat(&quot;This is a message&quot;)
</code></pre>

<pre><code class="r">qq.options(RESET = TRUE)
</code></pre>

<p>Not only simple scalars but also pieces of codes can be interpolated:</p>

<pre><code class="r">n = 1
qqcat(&quot;There @{ifelse(n == 1, &#39;is&#39;, &#39;are&#39;)} @{n} dog@{ifelse(n == 1, &#39;&#39;, &#39;s&#39;)}.\n&quot;)
</code></pre>

<pre><code>## There is 1 dog.
</code></pre>

<pre><code class="r">n = 2
qqcat(&quot;There @{ifelse(n == 1, &#39;is&#39;, &#39;are&#39;)} @{n} dog@{ifelse(n == 1, &#39;&#39;, &#39;s&#39;)}.\n&quot;)
</code></pre>

<pre><code>## There are 2 dogs.
</code></pre>

<p>If the text is too long, it can be wrapped into lines.</p>

<pre><code class="r">qq.options(&quot;cat_strwrap&quot; = TRUE)
qqcat(&quot;one, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty.&quot;)
</code></pre>

<pre><code>## one, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve, thirteen,
## fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty.
</code></pre>

<p><strong>NOTE:</strong> Since <code>qq</code> as the function name is very easy to be used by other packages
(E.g., in <strong>lattice</strong>, there is also a <code>qq()</code> function as well) and if so, you can enforce
<code>qq()</code> in your working environment as the function in <strong>GetoptLong</strong> by:</p>

<pre><code class="r">qq = GetoptLong::qq
</code></pre>

<h2 id="toc_1">Code patterns</h2>

<p>In above exmaple, <code>@{}</code> is used to mark variables. Later, variable names will be extracted from these marks
and replaced with their real values.</p>

<p>The marking code pattern can be any type. But you should make sure it is easy to tell the difference
from other part in the string. You can set your code pattern as an argument in <code>qq()</code>. The default pattern
is <code>@\\{CODE\\}</code> because  we only permit <code>CODE</code>
to return simple vectors and <code>@</code> is a sigil representing array in <strong>Perl</strong>.</p>

<p>In following example, the code pattern is <code>#{}</code>.</p>

<pre><code class="r">x = 1
qqcat(&quot;x = #{x}&quot;, code.pattern = &quot;#\\{CODE\\}&quot;)
</code></pre>

<pre><code>## x = 1
</code></pre>

<p>Or set in <code>qq.options()</code> as a global setting:</p>

<pre><code class="r">qq.options(&quot;code.pattern&quot; = &quot;#\\{CODE\\}&quot;)
</code></pre>

<p>As you can guess, in <code>@\\{CODE\\}</code>, <code>CODE</code> will be replaced with <code>.*?</code> to construct a regular
expression and to match variable names in the string. So if your <code>code.pattern</code> contains special characters,
make sure to escape them. Some candidate <code>code.pattern</code> are:</p>

<pre><code class="r">code.pattern = &quot;@\\{CODE\\}&quot;    # default style
code.pattern = &quot;@\\[CODE\\]&quot;
code.pattern = &quot;@\\(CODE\\)&quot;
code.pattern = &quot;%\\{CODE\\}&quot;
code.pattern = &quot;%\\[CODE\\]&quot;
code.pattern = &quot;%\\(CODE\\)&quot;
code.pattern = &quot;\\$\\{CODE\\}&quot;
code.pattern = &quot;\\$\\[CODE\\]&quot;
code.pattern = &quot;\\$\\(CODE\\)&quot;
code.pattern = &quot;#\\{CODE\\}&quot;
code.pattern = &quot;#\\[CODE\\]&quot;
code.pattern = &quot;#\\(CODE\\)&quot;
code.pattern = &quot;\\[%CODE%\\]&quot;  # Template Toolkit (Perl module) style :)
</code></pre>

<p>Since we just replace <code>CODE</code> to <code>.*?</code>, the function will only match to the first right parentheses/brackets.
(In <strong>Perl</strong>, I always use recursive regular expression to extract such pairing parentheses. But in <strong>R</strong>, it seems difficult.)
So, for example, if you are using <code>@\\[CODE\\]</code> and your string is <code>&quot;@[a[1]]&quot;</code>, it will fail to
extract the correct variable name while only extracts <code>a[1</code>, finally it generates an error when executing <code>a[1</code>. In such condition, you should use other pattern styles
that do not contain <code>[]</code>.</p>

<p>Finally, I suggest a more safe code pattern style that you do not need to worry about parentheses stuff:</p>

<pre><code class="r">code.pattern = &quot;`CODE`&quot;
</code></pre>

<h2 id="toc_2">Where to look for variables</h2>

<p>It will first look up in the envoking environment, then through searching path. Users can also pass values of variables
as a list like:</p>

<pre><code class="r">x = 1
y = 2
qqcat(&quot;x = @{x}, y = @{y}&quot;, envir = list(x = &quot;a&quot;, y = &quot;b&quot;))
</code></pre>

<pre><code>## x = a, y = b
</code></pre>

<p>If variables are passed through list, <code>qq()</code> only looks up in the specified list.</p>

<h2 id="toc_3">Variables should only return vectors</h2>

<p><code>qq()</code> only allows variables to return vectors. The whole string will be interpolated repeatedly according to longest vectors,
and finally concatenated into a single long string.</p>

<pre><code class="r">x = 1:6
qqcat(&quot;@{x} is an @{ifelse(x %% 2, &#39;odd&#39;, &#39;even&#39;)} number.\n&quot;)
</code></pre>

<pre><code>## 1 is an odd number. 2 is an even number. 3 is an odd number. 4 is an even number. 5 is an
## odd number. 6 is an even number.
</code></pre>

<pre><code class="r">y = c(&quot;a&quot;, &quot;b&quot;)
z = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;)
qqcat(&quot;@{x}, @{y}, @{z}\n&quot;)
</code></pre>

<pre><code>## 1, a, A 2, b, B 3, a, C 4, b, D 5, a, E 6, b, A
</code></pre>

<p>This feature is especially useful if you want to generate a report such as formatted in a HTML table:</p>

<pre><code class="r">name = letters[1:4]
value = 1:4
qqcat(&quot;&lt;tr&gt;&lt;td&gt;@{name}&lt;/td&gt;&lt;td&gt;@{value}&lt;/td&gt;&lt;tr&gt;\n&quot;)
</code></pre>

<pre><code>## &lt;tr&gt;&lt;td&gt;a&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;tr&gt; &lt;tr&gt;&lt;td&gt;b&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;tr&gt; &lt;tr&gt;&lt;td&gt;c&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;tr&gt;
## &lt;tr&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;tr&gt;
</code></pre>

<p>The returned value can also be a vector while not collapsed into one string:</p>

<pre><code class="r">str = qq(&quot;@{x}, @{y}, @{z}&quot;, collapse = FALSE)
length(str)
</code></pre>

<pre><code>## [1] 6
</code></pre>

<pre><code class="r">str
</code></pre>

<pre><code>## [1] &quot;1, a, A&quot; &quot;2, b, B&quot; &quot;3, a, C&quot; &quot;4, b, D&quot; &quot;5, a, E&quot; &quot;6, b, A&quot;
</code></pre>

<h2 id="toc_4">You can also interpolate more complicated codes</h2>

<p>Besides simple variables, you can also put chunk of codes in the string. 
Since <code>qq()</code> takes value of the last variable in the chunk as final returning value, you need 
to explicitly specify the return value in the chunk.</p>

<p>Following example is another way to contruct a HTML table in which the first row is assigned with class name.</p>

<pre><code class="r">name = letters[1:4]
value = 1:4
str = qq(&quot;
`
text = character(length(name))
for(i in seq_along(name)) {
    if(i == 1) {
        text[i] = qq(\&quot;&lt;tr class=&#39;highlight&#39;&gt;&lt;td&gt;@{name[i]}&lt;/td&gt;&lt;td&gt;@{value[i]}&lt;/td&gt;&lt;/tr&gt;\n\&quot;)
    } else {
        text[i] = qq(\&quot;&lt;tr&gt;&lt;td&gt;@{name[i]}&lt;/td&gt;&lt;td&gt;@{value[i]}&lt;/td&gt;&lt;/tr&gt;\n\&quot;)
    }
}
text
`&quot;, code.pattern = &quot;`CODE`&quot;)
</code></pre>

<pre><code class="r">cat(str)
</code></pre>

<pre><code>## 
## &lt;tr class=&#39;highlight&#39;&gt;&lt;td&gt;a&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
## 
## &lt;tr&gt;&lt;td&gt;b&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
## 
## &lt;tr&gt;&lt;td&gt;c&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;
## 
## &lt;tr&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;
</code></pre>

<p>In above example, the string also contains a <code>qq()</code> function, so please use different code patterns for them.</p>

<h2 id="toc_5">Simple template system</h2>

<p>More advanced, you can make a simple template system. E.g., put following code in <code>template.html</code>.
In the template, <strong>R</strong> codes are marked by <code>[%</code> and <code>%]</code>. Again, if <code>qq()</code> is called inside the <strong>R</strong> codes in
the template, you should use different code pattern instead of pattern in the template. That&#39;s why we use
a complicated code pattern (<code>[%CODE%]</code>) in the template.</p>

<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Report for [% report_name %]&lt;/h2&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
[% 
i = seq_along(name)
qq(&quot;&lt;tr@{ifelse(i == 1, &#39; class=\&quot;highlight\&quot;&#39;, &#39;&#39;)}&gt;&lt;td&gt;@{name}&lt;/td&gt;&lt;td&gt;@{value}&lt;/td&gt;&lt;/tr&gt;
&quot;)
%]
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Read <code>template.html</code> and do the interpolation:</p>

<pre><code class="r">template = paste(readLines(&quot;template.html&quot;), collapse = &quot;\n&quot;)

report_name = &quot;test&quot;
name = letters[1:4]
value = 1:4
html = qq(template, code.pattern = &quot;\\[%CODE%\\]&quot;)
writeLines(html, con = &quot;report.html&quot;)
</code></pre>

<p>You will get a report like:</p>

<pre><code>&lt;html&gt; &lt;body&gt; &lt;h2&gt;Report for test&lt;/h2&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt; &lt;tr
class=&quot;highlight&quot;&gt;&lt;td&gt;a&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;b&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;c&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;d&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt; &lt;/body&gt; &lt;/html&gt;
</code></pre>

<h2 id="toc_6">Session info</h2>

<pre><code class="r">sessionInfo()
</code></pre>

<pre><code>## R version 3.3.2 (2016-10-31)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: macOS Sierra 10.12.3
## 
## locale:
## [1] C/en_US.UTF-8/C/C/C/C
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] GetoptLong_0.1.6 knitr_1.15.1     markdown_0.7.7  
## 
## loaded via a namespace (and not attached):
## [1] rjson_0.2.15         magrittr_1.5         tools_3.3.2          GlobalOptions_0.0.10
## [5] stringi_1.1.2        stringr_1.1.0        mime_0.5             evaluate_0.10
</code></pre>

</body>

</html>
